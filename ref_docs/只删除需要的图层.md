你的判断非常准确。从 12 个图层删到只剩 6 个，这显然是**“杀红了眼” (Over-Pruning)**。我们的剪枝算法现在就像一个拿着机枪的守卫，只要稍微看着有点不对劲的人（Path），不管是不是良民（眼睛/鱼鳍），统统突突了。

现在的核心任务是：**把“机枪”换成“狙击枪”。** 我们需要精准地找到那个代表“鱼嘴”的 Path ID，只干掉它，保留其他。

既然你已经能跑通代码，我们现在采用一种 **“法医鉴定式”** 的调试方法，让你看清楚每一个 Path 到底是怎么死的，然后调整阈值救回它们。

---

### 🛠️ 解决方案：添加“剪枝诊断报告”

请不要盲目调整阈值数字（比如把 0.4 改成 0.6），因为你不知道多少才是对的。
我们要修改 `advanced_refine.py` 中的剪枝逻辑，让它**只打印“我想删谁”，但不真删**，并输出它判断的依据（分数）。

**请用下面的 `diagnostic_prune` 函数替换你原来的剪枝函数：**

```python
def diagnostic_prune(shapes, shape_groups, target_image, device, threshold=0.5):
    """
    诊断模式：不真删，只打印每个 Path 的存活情况和得分。
    """
    print(f"\n====== 🩺 Pruning Diagnosis Report (Threshold: {threshold}) ======")
    print(f"{'Path ID':<10} | {'Type':<10} | {'Path Color':<20} | {'Target Color':<20} | {'Diff':<10} | {'Verdict'}")
    print("-" * 100)

    prune_indices = []
    
    # 确保 Target 是 Tensor 且在 GPU
    if not torch.is_tensor(target_image):
        target_image = torch.from_numpy(target_image).to(device)
    
    h, w = target_image.shape[:2]

    for i, (path, group) in enumerate(zip(shapes, shape_groups)):
        # 1. 获取 Path 颜色
        path_color = None
        p_type = "Unknown"
        if group.fill_color is not None:
            path_color = group.fill_color
            p_type = "Fill"
        elif group.stroke_color is not None:
            path_color = group.stroke_color
            p_type = "Stroke"
        
        # 如果是无色路径，直接跳过
        if path_color is None:
            print(f"{i:<10} | {'Empty':<10} | {'N/A':<20} | {'N/A':<20} | {'N/A':<10} | Skip")
            continue

        # 2. 采样 Target 颜色 (使用 Bounding Box 中心采样，或者区域平均)
        # 这里用简单的中心点采样
        points = path.points
        center = points.mean(dim=0).long()
        cx, cy = center[0].item(), center[1].item()
        
        # 边界保护
        cx = max(0, min(w-1, cx))
        cy = max(0, min(h-1, cy))
        
        target_pixel = target_image[cy, cx] # RGBA
        
        # 3. 计算差异 (RGBA 欧氏距离)
        # 注意：Path color 可能在优化过程中变了，我们对比的是当前的 Path 和 Target
        diff = torch.norm(path_color - target_pixel).item()
        
        # 4. 判决
        verdict = "✅ KEEP"
        if diff > threshold:
            verdict = "❌ KILL"
            prune_indices.append(i)
            
        # 格式化打印
        p_c_str = f"[{path_color[0]:.2f}, {path_color[1]:.2f}, {path_color[2]:.2f}]"
        t_c_str = f"[{target_pixel[0]:.2f}, {target_pixel[1]:.2f}, {target_pixel[2]:.2f}]"
        
        print(f"{i:<10} | {p_type:<10} | {p_c_str:<20} | {t_c_str:<20} | {diff:.4f}     | {verdict}")

    print("=" * 100)
    return prune_indices
```

### 🔬 如何使用这份报告？

1.  **运行脚本：** 把阈值设低一点（比如 0.3），让它跑一遍。
2.  **查看控制台输出：**
    你会看到类似这样的表格：

    ```text
    Path ID    | Type       | Path Color           | Target Color         | Diff       | Verdict
    ----------------------------------------------------------------------------------------------------
    0          | Fill       | [0.00, 0.00, 0.00]   | [0.00, 0.00, 0.00]   | 0.0000     | ✅ KEEP  (这是底座)
    1          | Fill       | [0.90, 0.80, 0.10]   | [0.90, 0.80, 0.10]   | 0.0500     | ✅ KEEP  (这是身体)
    2          | Stroke     | [0.00, 0.00, 0.00]   | [0.00, 0.00, 0.00]   | 0.1200     | ✅ KEEP  (这是眼睛)
    3          | Stroke     | [0.00, 0.00, 0.00]   | [0.90, 0.80, 0.10]   | 0.8500     | ❌ KILL  (这是嘴巴！)
    4          | Fill       | [1.00, 0.50, 0.50]   | [0.00, 0.00, 0.00]   | 0.6500     | ❌ KILL  (这是鱼鳍 - 误杀)
    ```

3.  **精准调整：**
    *   找到 **嘴巴 (Path 3)** 的 Diff 分数：假设是 **0.85**。
    *   找到 **鱼鳍 (Path 4)** 的 Diff 分数：假设是 **0.65** (因为它背景是黑的，误差大)。
    *   找到 **眼睛 (Path 2)** 的 Diff 分数：假设是 **0.12**。

    **结论：** 你的阈值设在 **0.7** 就可以！
    *   0.7 < 0.85 (嘴巴被杀) ✅
    *   0.7 > 0.65 (鱼鳍保住了) ✅
    *   0.7 > 0.12 (眼睛保住了) ✅

### 🚀 终极方案：如果阈值很难调怎么办？

如果鱼鳍和嘴巴的分数太接近（比如都是 0.7 左右），阈值法就失效了。
这时候，用 **Rank (排名) 法**：

**只杀 Diff 最大的那 1 个 (Top-1 Pruning)。**

修改逻辑：
```python
    # 不看阈值，收集所有 diff
    all_diffs = []
    # ... 计算 diff ...
    all_diffs.append((diff, i))
    
    # 排序：误差最大的排前面
    all_diffs.sort(key=lambda x: x[0], reverse=True)
    
    # 只杀第一名！(最不像的那个)
    victim_id = all_diffs[0][1]
    print(f"🔪 Sniper Pruning: Killing Path {victim_id} (Diff: {all_diffs[0][0]:.4f})")
    
    return [victim_id]
```

**建议：** 先用 **诊断报告** 看看数据，如果能找到合适的阈值最好；找不到，就用 **Rank 法** 每次只杀一个最离谱的，多杀几轮直到满意为止。这是最稳的！